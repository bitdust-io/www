<!DOCTYPE html>
<html lang='en'>
    <head>


    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="canonical" href="http://bitdust.io">

    <title>Automatic Rebuilding</title>

    <meta property="fb:admins" content="1097958228"/>
    <meta property="fb:app_id" content="543329652498581"/>
    
    <meta name="author" content="Veselin Penev">
    <meta name="description" content="BitDust is a distributed on-line storage, in which only data owner has an access to his data.">    
    <meta name="keywords" content="BitDust, BitDust.IO, python, data storage, data storage, online data storage, distributed data storage, file storage,
        storage of files, save files, secure data storage, secure data storage, safely store the data, encrypted data storage,
        encrypted file storage, secure storage of files, save files, save folders safely save, store information,
        securely store information encrypted distributed data storage, cloud storage, backup, storage, backup data storage,
        data backup, anonymous messages decentralized online data storage, encrypt a message, encrypted messages, secure communication,
        communicate safely stored safely, securely store data, information storage, safe storage of information, communication,
        safely transmit information securely store information">

    <link rel="icon" href="favicon.ico"> 

    <script src="js/ba-debug.min.js" type="text/javascript"></script>

    <script src="js/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/ie10-viewport-bug-workaround.js"></script> 
    <link href="css/bootstrap.css" rel="stylesheet">
    <link href="css/topmenu.css" rel="stylesheet" type="text/css">
    <link href="css/bitdust.css" rel="stylesheet" type="text/css">
    
    <!-- <link href="css/reset.css" rel="stylesheet" type="text/css"> -->
    <!-- <link href="css/styles.css" rel="stylesheet" type="text/css"> -->
    <!-- <link href="css/main.css" rel="stylesheet" type="text/css"> -->
    <link href="css/automat.css" rel="stylesheet" type="text/css">
    <!--[if IE 7]>
    <link href="css/ie7.css" rel="stylesheet" type="text/css">
    <![endif]-->
    <!-- <link href="css/responsive.css" rel="stylesheet" type="text/css"> -->
   
</head>

<body>
    
<!-- Facebook Init -->
<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.5&appId=543329652498581";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>    

<div id=page_container class="Center-Container is-Inline">
<div class="Center-Block">
<div id=page_content>

<h1 id="Automatic-Rebuilding">Automatic Rebuilding</h1>

<ul>
<li><a href="rebuilding.html#data-redundancy">Data Redundancy</a></li>
<li><a href="rebuilding.html#raid-transformation">RAID Transformation</a></li>
<li><a href="rebuilding.html#ecc-codes">ECC codes</a></li>
<li><a href="rebuilding.html#rebuilding">Reassembly</a></li>
<li><a href="rebuilding.html#local-data-copies">Local Data Copies</a></li>
<li><a href="rebuilding.html#supplier-change">Supplier Change</a></li>
<li><a href="rebuilding.html#suppliers-search">Supplier Search</a></li>
</ul>

<h2 id="Data-Redundancy">Data Redundancy</h2>

<p>In the section <a href="storage.html">Data Storage</a> we described a mechanism of creating distributed user data copies in BitDust network. Here we will talk about a method of data partitioning into separate fragments, which enables dynamic recovery of lost data by their loss at one or several suppliers.</p>

<p>Data uploaded on user machines are stored there with double redundancy and are organized into RAID array for enabling a possibility of their recovery in case of loss.</p>

<p>The storage is organized in the following way: </p>

<ul>
<li>the first layer contains input data and is called Data </li>
<li>the second layer has the same size but modified content and is called Parity</li>
</ul>

<h2 id="RAID-Transformation">RAID Transformation</h2>

<p>Different combinations of Parity fragments enable Data fragment recovery on the machine of a new supplier, which swiftly replaced the lost one. Parity fragment for each block is created by conducting a byte operation XOR between several Data fragments of this block designed for other suppliers. </p>

<p>By losing one or few suppliers this allows restoring Data fragments from the fragments downloaded from other suppliers. For doing this one should do byte operation XOR between on hand Parity fragments once again.</p>

<p>The so-called iterative algorithm continues the work until it can restore at least one lost fragment in one cycle. For example, Data fragment recovery in one position on the first iteration allows restoring Parity parts in other positions in the next cycle, and then Data fragments will be restored in third positions etc. </p>

<h2 id="ECC-Codes">ECC Codes</h2>

<p>When building RAID array so-called EEC codes are used – these are combinations of locations of Data and Parity fragments on suppliers machines.</p>

<p>For each of the possible combinations of suppliers the optimal EEC code was calculated – it defines the framework of mutual bracing of Data and Parity fragments in the layers and maximum quantity of simultaneous errors, which may occur not leading to the block sustainability loss. Here you can see the allowable number of possible losses for each of the possible combinations of suppliers:</p>

<table>
<thead>
<tr>
  <th align="right"><strong>ecc code</strong></th>
  <th align="center"><strong>number of suppliers</strong></th>
  <th align="center"><strong>maximum errors</strong></th>
</tr>
</thead>
<tbody>
<tr>
  <td align="right">ecc/64x64</td>
  <td align="center">64</td>
  <td align="center">10</td>
</tr>
<tr>
  <td align="right">ecc/26x26</td>
  <td align="center">26</td>
  <td align="center">6</td>
</tr>
<tr>
  <td align="right">ecc/18x18</td>
  <td align="center">18</td>
  <td align="center">5</td>
</tr>
<tr>
  <td align="right">ecc/13x13</td>
  <td align="center">13</td>
  <td align="center">4</td>
</tr>
<tr>
  <td align="right">ecc/7x7</td>
  <td align="center">7</td>
  <td align="center">3</td>
</tr>
<tr>
  <td align="right">ecc/4x4</td>
  <td align="center">4</td>
  <td align="center">2</td>
</tr>
<tr>
  <td align="right">ecc2x2</td>
  <td align="center">2</td>
  <td align="center">1</td>
</tr>
</tbody>
</table>

<p>Thus percentage of possible losses makes 50% for 2 suppliers and up to 15% for 64 suppliers. However the greater the number of possible errors is, the more time the user has to reassemble the lost fragments and the more stable the data storage is.</p>

<h3 id="ATTENTION!">ATTENTION!</h3>

<pre><code>By exceeding the number of possible errors, expect complete loss of uploaded data. 
The mechanism of automatic recovery allows swiftly fixing encountered errors and 
enables new distribution of data on suppliers’ nodes. At the moment for this you 
need a BitDust program continuous running on the data owner machine and stable 
Internet connection.
</code></pre>

<h2 id="Rebuilding">Rebuilding</h2>

<p>Algorithm of dynamic data recovery cyclically runs a sequence of actions aimed at constant maintenance of a state in which data can be downloaded from the network.</p>

<p>In each algorithm iteration a decision making about change of this or that supplier based on the previously collected statistic data and current connection status takes place. The least "reliable" supplier can be fired and another node can be found in the BitDust network instead of him.</p>

<p>After changing supplier, those fragments which were allocated on the old node are lost and the process of reassembly of these fragments on user computer and further sending them to the new node start. For this the fragments will be beforehand downloaded from other suppliers which are available at the moment. </p>

<p>At each iteration of recovery algorithm there is a reassembly by blocks of each distributed in the BitDust network user data copy. The order of data assembly is organized by the time of creation of each copy – first will be restored the most recently uploaded data. </p>

<p>Here is a short representation of the common sequence of actions at each iteration:</p>

<ol>
<li>decision on supplier change is made – the least "reliable" node in the current combination is found</li>
<li>search for a new node which is ready to become a new supplier for the user is done in the global network</li>
<li>process of downloading already allocated data fragments from other suppliers is launched</li>
<li>for each block a RAID procedure for recovery of the lost fragments on the older node is done</li>
<li>restored fragments are uploaded to computer of the new supplier </li>
<li>after successful upload the restored fragments are deleted from the local disk drive (optional)</li>
</ol>

<h2 id="Local-Data-Copies">Local Data Copies</h2>

<p>By backup, data recovery from suppliers’ nodes and reassembly of lost fragments, the files for Data and Parity layers are "buffered" on the user local disk drive in the folder <code>.bitdust/backups/</code>.
In BitDust program settings you can find an option allowing you to keep on file these files after they have been uploaded on computers of remote suppliers or the recovery process is finished. In this case the space of the hard disk drive is used, but the level of reliability of information storage reaches the maximum.</p>

<p>While algorithm of automatic recovery runs, the download and further upload of data to ne remote nodes is done. In the worst possible case for changing one supplier you will need to download the whole uploaded in the BitDust network data. Enabling in the program settings an option responsible for storing local Data and Parity layers allows significantly decreasing the volume of used network traffic and process time. </p>

<p>Steps <code>3.</code>, <code>4.</code> and <code>6.</code> at each iteration of the algorithm of automatic recovery will be overjumped.</p>

<p>So this key adjustment lets the user choose between consumable computer resources: </p>

<ul>
<li>to use bigger space of local disk drive and get more reliable storage option </li>
<li>or to use more network traffic and process resources</li>
</ul>

<h2 id="Supplier-Change">Supplier Change</h2>

<p>The key moment in all the mechanism of automatic data recovery is the method of decision making on changing this or that user supplier. </p>

<p>Chosen EEC code influences the amount of possible mistakes in RAID array. In other words the quantity of possible lost fragments in each block having which you still can reassemble the whole block. </p>

<p>At each iteration of the algorithm of automatic recovery the estimation of number of connected at the moment suppliers is done, as well as the matching of it to the possible number of losses for the given EEC method. If the number of inactive suppliers is critically great, then the momentary change of one or several suppliers will be done and reassembly of all uploaded data and their transfer to the new nodes is underway.</p>

<p>At the moment this functional in the BitDust program is realized on the basic level and needs further development for optimal decision making. However this requires a real environment for testing its working efficiency – we need greater number of real users, which dynamically log on and out of the network. </p>

<p>In the future we plan to boost this functional so that it could "predict" beforehand the change of this or that supplier in the general combination by previously collected day statistics. This will allow downloading those fragments of Data and Parity layers which are located on the node of supposedly "unreliable" supplier and then afterwards changing it. This approach will contribute to significant decrease in consumable resources of the data owner personal computer: namely network channel and process time.</p>

<p>It bears mentioning that to our forecasts the change of suppliers will be done rare enough as statistically the more reliable nodes will not be exposed to change. After formation of the first suppliers combination their combined reliability will steadily increase. After reaching particular state the changes will take place in very rare cases and can be easily predicted which allows using the minimum PC resources for reassembly.</p>

<p>In the future we plan to create conditions for external praising of users who give resources of their personal computers to the network as this will stimulate the more reliable another’s data storage.</p>

<h2 id="Suppliers-Search">Suppliers Search</h2>

<p>By supplier change the search of a new node in the BitDust network is done under present parameters:</p>

<ul>
<li>the volume of requested from the network space</li>
<li>the number of suppliers in the combination – it depends on the chosen EEC method</li>
</ul>

<p>For this the distributed hash-table is addressed and the random node is chosen. Then this node is connected and sent a request for giving a service of storing data for the user. By acceptance the chosen node becomes a new users supplier. In the event of a refusal the algorithm of search goes backwards and does a new try – chooses a random node from the hash-table and starts connection.</p>

<p>Statistically random suppliers search method allows increasing the level of data storage security to some extent as the possible attacker would not guess which node will be the new supplier of the given user and accordingly would not be able to change it with the node under his control.</p>

<p>BitDust network does not create and use centralized suppliers or clients ratings or other global network nodes lists. However quite possibly these kind of lists could be useful at a certain stage of project development (for example, for testing, debugging and optimization) and the decision in favor of their use will be adopted. In this case each user will be given a right of free choice whether to become a part of a global centralized list.</p>

<div class="fb-comments" data-href="http://bitdust.io/rebuilding.html" data-numposts="5" data-width="100%" data-colorscheme="light">

</div>


</div>
</div>
</div>


<div id="bottom_area">
<div id=copyright>
© Copyright 2015 BitDust LLC. 
Using web site, software and other products
branded  <b>BitDust</b> means agree with the
<a href="http://bitdust.io/license.html"> license agreement </a>.
All rights reserved.
</div>
</div>



<div id="top_area">
    <nav class="navbar navbar-default navbar-static-top">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                </button>
                <div id="top_search_panel">
                    <input type="text" id="top_search_input" placeholder="have a question?">
                    <button type="button" id="top_search_button">ask</button>
                </div>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                <ul class="nav navbar-nav navbar-left">
                    <!-- <li><a href=""><span style="font-size: 1.5em;">BitDust</span></a></li> -->
                    <!-- <li><a href="download.html">download</a></li> -->
                    <!-- 
                    <li><a href="intro.html">about</a></li>
                    <li><a href="concept.html">concept</a></li>
                    <li><a href="principle.html">principle</a></li>
                    <li><a href="donate.html">donate</a></li>
                    <li><a href="givejob.html">give me a job?</a></li>
                    -->
                </ul>
                
                <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="" id="main_download" class="btn btn-primary btn-lg top_menu_button" >DOWNLOAD</a>
                    </li>
                
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
                            <span class="glyphicon glyphicon-menu-hamburger" aria-hidden="true"></span>
                            Why Bitdust?
                            <span class="caret"></span>
                        </a>
                        <ul class="dropdown-menu" role="menu">
                            <li><a href="">NO PASSWORDS!</a></li>
                            <li><a href="security.html">100% Security</a></li>
                            <li><a href="">P2P Anonymous</a></li>
                            <li><a href="">Open Source</a></li>
                            <li><a href="">Good Team</a></li>
                            <li><a href="roadmap.html">Road Map</a></li>
                        </ul>
                    </li>
                    
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
                            <span class="glyphicon glyphicon-menu-hamburger" aria-hidden="true"></span>
                            Docs
                            <span class="caret"></span>
                        </a>
                        <ul class="dropdown-menu" role="menu">
                            <li><a href="toc.html">Table of contents</a></li>
                            <li><a href="intro.html">Intro</a></li>
                            <li><a href="concept.html">Concept</a></li>
                            <li><a href="principle.html">Principle</a></li>
                            <li><a href="glossary.html">Glossary</a></li>
                        </ul>
                    </li>

                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
                            <span class="glyphicon glyphicon-menu-hamburger" aria-hidden="true"></span>
                            Team
                            <span class="caret"></span>
                        </a>
                        <ul class="dropdown-menu" role="menu">
                            <li><a href="develop.html">Get a Task!</a></li>
                            <li><a href="donate.html">Donate $</a></li>
                            <li><a href="givejob.html">Give me a Job?</a></li>
                            <li><a href="">Project Founders</a></li>
                        </ul>
                    </li>
                    
                    <li>
                        <a href="https://github.com/vesellov" target="blank" class="top_menu_button" id="github_button">GitHub</a>
                    </li>
                    
                    <li>
                    <!-- <div class="fb-like" data-share="true" data-width="450" data-show-faces="true"></div> -->
                    </li>
                </ul>
                
            </div><!--/.nav-collapse -->   
        </div>
    </nav>
</div>


<!-- Yandex.Metrika counter -->
<script type="text/javascript">
(function (d, w, c) {    (w[c] = w[c] || []).push(function() {
        try {            w.yaCounter28171152 = new Ya.Metrika({id:28171152,
        webvisor:true,                    clickmap:true,                    trackLinks:true,                    accurateTrackBounce:true});
        } catch(e) { }    });
    var n = d.getElementsByTagName("script")[0],
        s = d.createElement("script"),
        f = function () { n.parentNode.insertBefore(s, n); };
    s.type = "text/javascript";
    s.async = true;
    s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";
    if (w.opera == "[object Opera]") {        d.addEventListener("DOMContentLoaded", f, false);    } else { f(); }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="//mc.yandex.ru/watch/28171152" style="position:absolute; left:-9999px;" alt="" /></div></noscript>


<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-59191888-1', 'auto');
  ga('send', 'pageview');
</script>



</body>
</html>
