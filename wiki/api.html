<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title data-content="pageTitle">BitDust - Decentralized on-line storage network</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">

    <meta property="og:image:height" content="1257">
    <meta property="og:image:width" content="2400">
    <meta property="og:title" content="BitDust - decentralized on-line storage network">
    <meta property="og:description"
          content="BitDust is distributed secure anonymous on-line storage, where only the owner has access and absolute control over its data.">
    <meta property="og:url" content="https://bitdust.io">
    <meta property="og:image" content="/assets/img/og/og-image.jpg">

    <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:600,700" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:600" rel="stylesheet">

    <link rel="stylesheet" href="/assets/css/applify.min.css" />
    <link rel="stylesheet" href="/css/automat.css" type="text/css">
</head>
<body data-fade_in="on-load">

<nav class="navbar navbar-fixed-top navbar-dark bg-indigo">
    <div class="container">

        <!-- Navbar Logo -->
        <a class="ui-variable-logo navbar-brand" href="https://bitdust.io/" title="BitDust">
            <!-- Default Logo -->
            <img class="logo-default" src="/assets/img/logo/bitdust-logo-white.svg"
                 alt="BitDust">
            <!-- Transparent Logo -->
            <img class="logo-transparent" src="/assets/img/logo/bitdust-logo-white.svg"
                 alt="BitDust">
        </a><!-- .navbar-brand -->

        <!-- Navbar Navigation -->
        <div class="ui-navigation navbar-center">
            <ul class="nav navbar-nav">
                <!-- Nav Item -->
                <li>
                    <a href="/index.html#product">Product</a>
                </li>
                <!-- Nav Item -->
                <li>
                    <a href="/index.html#problem">Problem</a>
                </li>
                <!-- Nav Item -->
                <li>
                    <a href="/index.html#solution">Solution</a>
                </li>
                <!-- Nav Item -->
                <li>
                    <a href="/index.html#ecosystem">Ecosystem</a>
                </li>
                <!-- Nav Item -->
                <li>
                    <a href="/index.html#roadmap">Roadmap</a>
                </li>
                <!-- Nav Item -->
                <li>
                    <a href="/index.html#team">Team</a>
                </li>
                <!-- Nav Item -->
                <li class="active">
                    <a href="/wiki/">Wiki</a>
                </li>

            </ul><!--.navbar-nav -->
        </div><!--.ui-navigation -->

        <!-- Navbar Button -->
        <a href="/index.html#product"
           class="btn btn-sm ui-gradient-peach pull-right">
            Get Started
        </a>


    </div><!-- .container -->
</nav> <!-- nav -->


<div class="main wiki" role="main">

    <!-- Api Docs -->
    <div id="ui-api-docs" class="section bg-light">
        <div class="container" style="max-width: 1580px;">

            <div class="ui-card">
                <div class="card-body">
                    <div class="row">

                        <!-- Docs Sidebar -->
                        <div class="docs-sidebar col-md-2">

                            <h6 class="heading">
                                Beginning
                            </h6>
                            <ul>
                                <li><a href="/wiki/intro.html">Introduction</a></li>
                                <li><a href="/wiki/concept.html">Concept</a></li>
                                <li><a href="/wiki/principle.html">How Does It Work?</a></li>
                                <li><a href="/wiki/install.html">Installation</a></li>
                                <li><a href="/wiki/commands.html">Commands</a></li>
                                <li><a href="/wiki/settings.html">Settings</a></li>
                                <li><a href="/wiki/glossary.html">Glossary</a></li>
                            </ul>
                            <h6 class="heading">
                                Principles
                            </h6>
                            <ul>
                                <li><a href="/wiki/identities.html">User Identification</a></li>
                                <li><a href="/wiki/storage.html">Distributed Storage</a></li>
                                <li><a href="/wiki/security.html">Data Security</a></li>
                                <li><a href="/wiki/sharing.html">File Sharing</a></li>
                                <li><a href="/wiki/rebuilding.html">Automatic Rebuilding</a></li>
                                <li><a href="/wiki/dht.html">Distributed Hash-Table</a></li>
                                <li><a href="/wiki/services.html">Network services</a></li>
                            </ul>
                            <h6 class="heading">Development</h6>
                            <ul>
                                <li><a href="/wiki/contribution.html">Contribution</a></li>
                                <li><a href="/wiki/roadmap.html">Roadmap</a></li>
                                <li><a href="/wiki/automats.html">Finite State Machines</a></li>
                                <li><a href="/wiki/technologies.html">Technologies</a></li>
                                <li><a href="/wiki/api.html">API Interface</a></li>
                                <li><a href="/wiki/software_releases.html">Software releases</a></li>
                                <li><a href="/wiki/seed_node.html">Seed node</a></li>
                                <li><a href="/wiki/respect.html">Contributors and Supporters</a></li>
                            </ul>


                            <h6 class="heading">Repositories</h6>
                            <ul>
                                <li>
                                    <a href="https://github.com/bitdust-io"
                                       target="blank">
                                        <i class="fa fa-github text-purple"></i>
                                        GitHub/bitdust-io
                                    </a>
                                </li>
                                <li>
                                    <a href="https://bitbucket.org/bitdust_io"
                                       target="blank">
                                        <i class="fa fa-github text-purple"></i>
                                        BitBucket/bitdust_io
                                    </a>
                                </li>
                                <li>
                                    <a href="https://gitlab.com/bitdust.io"
                                       target="blank">
                                        <i class="fa fa-github text-purple"></i>
                                        GitLab/bitdust.io
                                    </a>
                                </li>
                                <li>
                                    <a href="https://dev.bitdust.io/explore/projects"
                                       target="blank">
                                        <i class="fa fa-github text-purple"></i>
                                        dev.bitdust.io
                                    </a>
                                </li>
                            </ul>

                            <h6 class="heading" style="margin-bottom: 10px;">API methods</h6>

<a href="#process_stop">process_stop</a><br>
<a href="#process_restart">process_restart</a><br>
<a href="#process_health">process_health</a><br>
<a href="#process_debug">process_debug</a><br>
<a href="#config_get">config_get</a><br>
<a href="#config_set">config_set</a><br>
<a href="#configs_list">configs_list</a><br>
<a href="#configs_tree">configs_tree</a><br>
<a href="#identity_get">identity_get</a><br>
<a href="#identity_create">identity_create</a><br>
<a href="#identity_backup">identity_backup</a><br>
<a href="#identity_recover">identity_recover</a><br>
<a href="#identity_erase">identity_erase</a><br>
<a href="#identity_rotate">identity_rotate</a><br>
<a href="#identity_cache_list">identity_cache_list</a><br>
<a href="#key_get">key_get</a><br>
<a href="#keys_list">keys_list</a><br>
<a href="#key_create">key_create</a><br>
<a href="#key_label">key_label</a><br>
<a href="#key_erase">key_erase</a><br>
<a href="#key_share">key_share</a><br>
<a href="#key_audit">key_audit</a><br>
<a href="#files_sync">files_sync</a><br>
<a href="#file_exists">file_exists</a><br>
<a href="#file_info">file_info</a><br>
<a href="#file_create">file_create</a><br>
<a href="#file_delete">file_delete</a><br>
<a href="#files_uploads">files_uploads</a><br>
<a href="#file_upload_start">file_upload_start</a><br>
<a href="#file_upload_stop">file_upload_stop</a><br>
<a href="#files_downloads">files_downloads</a><br>
<a href="#file_download_start">file_download_start</a><br>
<a href="#file_download_stop">file_download_stop</a><br>
<a href="#file_explore">file_explore</a><br>
<a href="#shares_list">shares_list</a><br>
<a href="#share_create">share_create</a><br>
<a href="#share_delete">share_delete</a><br>
<a href="#share_grant">share_grant</a><br>
<a href="#share_open">share_open</a><br>
<a href="#share_close">share_close</a><br>
<a href="#share_history">share_history</a><br>
<a href="#groups_list">groups_list</a><br>
<a href="#group_create">group_create</a><br>
<a href="#group_info">group_info</a><br>
<a href="#group_join">group_join</a><br>
<a href="#group_leave">group_leave</a><br>
<a href="#group_share">group_share</a><br>
<a href="#friends_list">friends_list</a><br>
<a href="#friend_add">friend_add</a><br>
<a href="#friend_remove">friend_remove</a><br>
<a href="#user_ping">user_ping</a><br>
<a href="#user_status">user_status</a><br>
<a href="#user_status_check">user_status_check</a><br>
<a href="#user_search">user_search</a><br>
<a href="#user_observe">user_observe</a><br>
<a href="#message_history">message_history</a><br>
<a href="#message_send">message_send</a><br>
<a href="#message_send_group">message_send_group</a><br>
<a href="#message_receive">message_receive</a><br>
<a href="#suppliers_list">suppliers_list</a><br>
<a href="#supplier_change">supplier_change</a><br>
<a href="#suppliers_ping">suppliers_ping</a><br>
<a href="#suppliers_dht_lookup">suppliers_dht_lookup</a><br>
<a href="#customers_list">customers_list</a><br>
<a href="#customer_reject">customer_reject</a><br>
<a href="#customers_ping">customers_ping</a><br>
<a href="#space_donated">space_donated</a><br>
<a href="#space_consumed">space_consumed</a><br>
<a href="#space_local">space_local</a><br>
<a href="#services_list">services_list</a><br>
<a href="#service_info">service_info</a><br>
<a href="#service_start">service_start</a><br>
<a href="#service_stop">service_stop</a><br>
<a href="#service_restart">service_restart</a><br>
<a href="#packets_list">packets_list</a><br>
<a href="#packets_stats">packets_stats</a><br>
<a href="#transfers_list">transfers_list</a><br>
<a href="#connections_list">connections_list</a><br>
<a href="#streams_list">streams_list</a><br>
<a href="#queues_list">queues_list</a><br>
<a href="#queue_consumers_list">queue_consumers_list</a><br>
<a href="#queue_producers_list">queue_producers_list</a><br>
<a href="#event_send">event_send</a><br>
<a href="#event_listen">event_listen</a><br>
<a href="#network_stun">network_stun</a><br>
<a href="#network_reconnect">network_reconnect</a><br>
<a href="#network_connected">network_connected</a><br>
<a href="#network_configuration">network_configuration</a><br>
<a href="#dht_node_find">dht_node_find</a><br>
<a href="#dht_user_random">dht_user_random</a><br>
<a href="#dht_value_get">dht_value_get</a><br>
<a href="#dht_value_set">dht_value_set</a><br>
<a href="#dht_local_db_dump">dht_local_db_dump</a><br>
<a href="#automats_list">automats_list</a><br>

                        </div>

                        <div class="docs-content col-md-10">


                            <div class="docs-section doc-action-cards">
                                <h1 id="bitdust-api">BitDust API</h1>

<ul>
<li><a href="api.html#intro">Intro</a></li>
<li><a href="api.html#access">Access</a></li>
<li><a href="api.html#api-methods">API methods</a></li>
</ul>

<h2 id="intro">Intro</h2>

<p>Make sure your BitDust engine process is already running on that machine first.</p>

<p>There are multiple ways you can interract with the BitDust engine main process.
Here you can find some examples of how to do that using different clients.</p>

<h4 id="http-rest-api">HTTP Rest API</h4>

<p>The API server inside the engine is running on <code>localhost:8180</code> by default.
This can be modified via program settings.</p>

<p>You can use <code>curl</code> command to execute HTTP calls directly:</p>

<pre><code>curl -X GET -H 'api_secret:abc' 'localhost:8180/process/health/v1'
{
  "execution": "0.000107",
  "status": "OK"
}
</code></pre>

<h4 id="websocket">WebSocket</h4>

<p>The WebSocket server inside the engine is running on <code>localhost:8280</code> by default.
This can be modified via program settings.</p>

<p>Here is a very basic example of a JavaScript WebSocket client call:</p>

<pre><code>var websocket = null;
websocket = new WebSocket("ws://127.0.0.1:8280?api_secret=abc");
websocket.binaryType = "arraybuffer";
websocket.onopen = function() {
    websocket.send('{"command": "api_call", "method": "process_health", "kwargs": {} }');
};
websocket.onmessage = function(e) {
    if (typeof e.data == "string") {
        console.log("WebSocket message received: " + e.data);
    }
};
</code></pre>

<h4 id="command-line-shell-client">Command line shell client</h4>

<p>Command line client is actually also using HTTP Rest API interface to interact with the main process.</p>

<p>To get more details about how to use BitDust via command line type in your terminal shell:</p>

<pre><code>bitdust help
</code></pre>

<h2 id="access">Access</h2>

<p>Both HTTP and WebSocket interfaces are only accepting connections from the local host. This is an intended restriction
to prevent any kind of access from outside of the host operation system to the main BitDust process.
This way BitDust do not require user to have any kind of credentials to access the application.</p>

<p>To block access to BitDust API interface for non-authorized local clients a secret API token was introduced.
That feature suppose to be enabled by default if you just installed the application for the first time.</p>

<p>To verify that secret token is in use you need to open the folder <code>.bitdust/metadata/</code> and
check if a file <code>.bitdust/metadata/apisecret</code> exists and is not empty.
The file contains base64-formatted random token which is generated automatically by the application.</p>

<p>Authorized clients running on same operating system such as UI client and command line shell client will read that file from the disk and be
able to access the API methods. Non-authorized local clients that do not have access to the host operating system
will not be able to access the API.</p>

<h2 id="api-methods">API methods</h2>

<p>You can find bellow a list of all API methods available at the moment.</p>

<h4 class="api_method" id="process_stop">process_stop()</h4>

<p>Stop the main process immediately.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/process/stop/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "process_stop", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="process_restart">process_restart()</h4>

<p>Restart the main process.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/process/restart/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "process_restart", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="process_health">process_health()</h4>

<p>Returns positive response if engine process is running. This method suppose to be used for health checks.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/process/health/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "process_health", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="process_debug">process_debug()</h4>

<p>Execute a breakpoint inside the main thread and start Python shell using standard <code>pdb.set_trace()</code> debugger method.</p>

<p>This is only useful if you already have executed the BitDust engine manually via shell console and would like
to interrupt it and investigate things.</p>

<p>This call will block the main process and it will stop responding to any API calls.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/process/debug/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "process_debug", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="config_get">config_get(key)</h4>

<p>Returns current key/value from the program settings.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/config/get/v1?key=logs/debug-level'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "config_get", "kwargs": {"key": "logs/debug-level"} }');
</code></pre>

<h4 class="api_method" id="config_set">config_set(key, value)</h4>

<p>Set a value for given key option.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/config/set/v1' -d '{"key": "logs/debug-level", "value": 12}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "config_set", "kwargs": {"key": "logs/debug-level", "value": 12} }');
</code></pre>

<h4 class="api_method" id="configs_list">configs_list(sort=False)</h4>

<p>Provide detailed info about all program settings.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/config/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "configs_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="configs_tree">configs_tree()</h4>

<p>Returns all options as a tree structure, can be more suitable for UI operations.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/config/tree/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "configs_tree", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="identity_get">identity_get(include_xml_source=False)</h4>

<p>Returns your identity info.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/identity/get/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "identity_get", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="identity_create">identity_create(username, preferred_servers=[])</h4>

<p>Generates new private key and creates new identity for you to be able to communicate with other nodes in the network.</p>

<p>Parameter <code>username</code> defines filename of the new identity.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/identity/create/v1' -d '{"username": "alice"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "identity_create", "kwargs": {"username": "alice"} }');
</code></pre>

<h4 class="api_method" id="identity_backup">identity_backup(destination_filepath)</h4>

<p>Creates local file at <code>destination_filepath</code> on your disk drive with a backup copy of your private key and recent IDURL.</p>

<p>You can use that file to restore identity in case of lost data using <code>identity_recover()</code> API method.</p>

<p>WARNING! Make sure to always have a backup copy of your identity secret key in a safe place - there is no other way
to restore your data in case of lost.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/identity/backup/v1' -d '{"destination_filepath": "/tmp/alice_backup.key"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "identity_backup", "kwargs": {"destination_filepath": "/tmp/alice_backup.key"} }');
</code></pre>

<h4 class="api_method" id="identity_recover">identity_recover(private_key_source, known_idurl=None)</h4>

<p>Restores your identity from backup copy.</p>

<p>Input parameter <code>private_key_source</code> must contain your latest IDURL and the private key as openssh formated string.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/identity/recover/v1' -d '{"private_key_source": "http://some-host.com/alice.xml\n-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKC..."}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "identity_recover", "kwargs": {"private_key_source": "http://some-host.com/alice.xml\n-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKC..."} }');
</code></pre>

<h4 class="api_method" id="identity_erase">identity_erase(erase_private_key=False)</h4>

<p>Method will erase current identity file and the private key (optionally).
All network services will be stopped first.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X DELETE 'localhost:8180/identity/erase/v1' -d '{"erase_private_key": true}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "identity_erase", "kwargs": {"erase_private_key": true} }');
</code></pre>

<h4 class="api_method" id="identity_rotate">identity_rotate()</h4>

<p>Rotate your identity sources and republish identity file on another ID server even if current ID servers are healthy.</p>

<p>Normally that procedure is executed automatically when current process detects unhealthy ID server among your identity sources.</p>

<p>This method is provided for testing and development purposes.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X PUT 'localhost:8180/identity/rotate/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "identity_rotate", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="identity_cache_list">identity_cache_list()</h4>

<p>Returns list of all cached locally identity files received from other users.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/identity/cache/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "identity_cache_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="key_get">key_get(key_id, include_private=False)</h4>

<p>Returns details of the registered public or private key.</p>

<p>Use <code>include_private=True</code> if you also need a private key (as openssh formated string) to be present in the response.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/key/get/v1?key_id=abcd1234$alice@server-a.com'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "key_get", "kwargs": {"key_id": "abcd1234$alice@server-a.com"} }');
</code></pre>

<h4 class="api_method" id="keys_list">keys_list(sort=False, include_private=False)</h4>

<p>List details for all registered public and private keys.</p>

<p>Use <code>include_private=True</code> if you also need a private key (as openssh formated string) to be present in the response.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/key/list/v1?include_private=1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "keys_list", "kwargs": {"include_private": 1} }');
</code></pre>

<h4 class="api_method" id="key_create">key_create(key_alias, key_size=None, label="", include_private=False)</h4>

<p>Generate new RSA private key and add it to the list of registered keys with a new <code>key_id</code>.</p>

<p>Optional input parameter <code>key_size</code> can be 1024, 2048, 4096. If <code>key_size</code> was not passed, default value will be
populated from the <code>personal/private-key-size</code> program setting.</p>

<p>Parameter <code>label</code> can be used to attach some meaningful information for the user to display in the UI.</p>

<p>Use <code>include_private=True</code> if you also need a private key (as openssh formated string) to be present in the response.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/key/create/v1' -d '{"key_alias": "abcd1234", "key_size": 1024, "label": "Cats and Dogs"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "key_create", "kwargs": {"key_alias": "abcd1234", "key_size": 1024, "label": "Cats and Dogs"} }');
</code></pre>

<h4 class="api_method" id="key_label">key_label(key_id, label)</h4>

<p>Set new label for the given key.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/key/label/v1' -d '{"key_id": "abcd1234$alice@server-a.com", "label": "Man and Woman"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "key_label", "kwargs": {"key_id": "abcd1234$alice@server-a.com", "label": "Man and Woman"} }');
</code></pre>

<h4 class="api_method" id="key_erase">key_erase(key_id)</h4>

<p>Unregister and remove given key from the list of known keys and erase local file.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X DELETE 'localhost:8180/key/erase/v1' -d '{"key_id": "abcd1234$alice@server-a.com"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "key_erase", "kwargs": {"key_id": "abcd1234$alice@server-a.com"} }');
</code></pre>

<h4 class="api_method" id="key_share">key_share(key_id, trusted_user_id, include_private=False, timeout=10)</h4>

<p>Connects to remote user and transfer given public or private key to that node.
This way you can share access to files/groups/resources with other users in the network.</p>

<p>If you pass <code>include_private=True</code> also private part of the key will be shared, otherwise only public part.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X PUT 'localhost:8180/key/share/v1' -d '{"key_id": "abcd1234$alice@server-a.com", "trusted_user_id": "bob@machine-b.net"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "key_share", "kwargs": {"key_id": "abcd1234$alice@server-a.com", "trusted_user_id": "bob@machine-b.net"} }');
</code></pre>

<h4 class="api_method" id="key_audit">key_audit(key_id, untrusted_user_id, is_private=False, timeout=10)</h4>

<p>Connects to remote node identified by <code>untrusted_user_id</code> parameter and request audit of given public or private key <code>key_id</code> on that node.</p>

<p>Returns positive result if audit process succeed - that means remote user really possess the key.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/key/audit/v1' -d '{"key_id": "abcd1234$alice@server-a.com", "untrusted_user_id": "carol@computer-c.net", "is_private": 1}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "key_audit", "kwargs": {"key_id": "abcd1234$alice@server-a.com", "untrusted_user_id": "carol@computer-c.net", "is_private": 1} }');
</code></pre>

<h4 class="api_method" id="files_sync">files_sync()</h4>

<p>This should re-start "data synchronization" process with your remote suppliers.</p>

<p>Normally all communications and synchronizations are handled automatically, so you do not need to
call that method.</p>

<p>This method is provided for testing and development purposes.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/file/sync/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "files_sync", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="file_exists">file_exists(remote_path)</h4>

<p>Returns positive result if file or folder with such <code>remote_path</code> already exists in the catalog.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/file/exists/v1?remote_path=abcd1234$alice@server-a.com:pictures/cats/pussy.png'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "file_exists", "kwargs": {"remote_path": "abcd1234$alice@server-a.com:pictures/cats/pussy.png"} }');
</code></pre>

<h4 class="api_method" id="file_info">file_info(remote_path, include_uploads=True, include_downloads=True)</h4>

<p>Returns detailed info about given file or folder in the catalog.</p>

<p>You can also use <code>include_uploads</code> and <code>include_downloads</code> parameters to get more info about currently running
uploads and downloads.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/file/info/v1?remote_path=abcd1234$alice@server-a.com:pictures/dogs/bobby.jpeg'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "file_info", "kwargs": {"remote_path": "abcd1234$alice@server-a.com:pictures/dogs/bobby.jpeg"} }');
</code></pre>

<h4 class="api_method" id="file_create">file_create(remote_path, as_folder=False, exist_ok=False, force_path_id=None)</h4>

<p>Creates new file in the catalog, but do not upload any data to the network yet.</p>

<p>This method only creates a "virtual ID" for the new data.</p>

<p>Pass <code>as_folder=True</code> to create a virtual folder instead of a file.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/file/create/v1' -d '{"remote_path": "abcd1234$alice@server-a.com:movies/travels/safari.mp4"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "file_create", "kwargs": {"remote_path": "abcd1234$alice@server-a.com:movies/travels/safari.mp4"} }');
</code></pre>

<h4 class="api_method" id="file_delete">file_delete(remote_path)</h4>

<p>Removes virtual file or folder from the catalog and also notifies your remote suppliers to clean up corresponding uploaded data.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/file/delete/v1' -d '{"remote_path": "abcd1234$alice@server-a.com:cars/ferrari.gif"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "file_delete", "kwargs": {"remote_path": "abcd1234$alice@server-a.com:cars/ferrari.gif"} }');
</code></pre>

<h4 class="api_method" id="files_uploads">files_uploads(include_running=True, include_pending=True)</h4>

<p>Returns a list of currently running uploads and list of pending items to be uploaded.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/file/upload/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "files_uploads", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="file_upload_start">file_upload_start(local_path, remote_path, wait_result=False, open_share=False)</h4>

<p>Starts a new file or folder (including all sub-folders and files) upload from <code>local_path</code> on your disk drive
to the virtual location <code>remote_path</code> in the catalog. New "version" of the data will be created for given catalog item
and uploading task started.</p>

<p>You can use <code>wait_result=True</code> to block the response from that method until uploading finishes or fails (makes no sense for large uploads).</p>

<p>Parameter <code>open_share</code> can be useful if you uploading data into a "shared" virtual path using another key that shared to you.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/file/upload/start/v1' -d '{"remote_path": "abcd1234$alice@server-a.com:cars/fiat.jpeg", "local_path": "/tmp/fiat.jpeg"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "file_upload_start", "kwargs": {"remote_path": "abcd1234$alice@server-a.com:cars/fiat.jpeg", "local_path": "/tmp/fiat.jpeg"} }');
</code></pre>

<h4 class="api_method" id="file_upload_stop">file_upload_stop(remote_path)</h4>

<p>Useful method if you need to interrupt and cancel already running uploading task.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/file/upload/stop/v1' -d '{"remote_path": "abcd1234$alice@server-a.com:cars/fiat.jpeg"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "file_upload_stop", "kwargs": {"remote_path": "abcd1234$alice@server-a.com:cars/fiat.jpeg"} }');
</code></pre>

<h4 class="api_method" id="files_downloads">files_downloads()</h4>

<p>Returns a list of currently running downloading tasks.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/file/download/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "files_downloads", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="file_download_start">file_download_start(remote_path, destination_path=None, wait_result=False, open_share=True)</h4>

<p>Download data from remote suppliers to your local machine.</p>

<p>You can use different methods to select the target data with <code>remote_path</code> input:</p>

<ul>
<li>"virtual" path of the file</li>
<li>internal path ID in the catalog</li>
<li>full data version identifier with path ID and version name</li>
</ul>

<p>It is possible to select the destination folder to extract requested files to.
By default this method uses specified value from <code>paths/restore</code> program setting or user home folder.</p>

<p>You can use <code>wait_result=True</code> to block the response from that method until downloading finishes or fails (makes no sense for large files).</p>

<p>WARNING! Your existing local data in <code>destination_path</code> will be overwritten!</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/file/download/start/v1' -d '{"remote_path": "abcd1234$alice@server-a.com:movies/back_to_the_future.mp4", "local_path": "/tmp/films/"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "file_download_start", "kwargs": {"remote_path": "abcd1234$alice@server-a.com:movies/back_to_the_future.mp4", "local_path": "/tmp/films/"} }');
</code></pre>

<h4 class="api_method" id="file_download_stop">file_download_stop(remote_path)</h4>

<p>Abort currently running restore process.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/file/download/stop/v1' -d '{"remote_path": "abcd1234$alice@server-a.com:cars/fiat.jpeg"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "file_download_stop", "kwargs": {"remote_path": "abcd1234$alice@server-a.com:cars/fiat.jpeg"} }');
</code></pre>

<h4 class="api_method" id="file_explore">file_explore(local_path)</h4>

<p>Useful method to be executed from the UI right after downloading is finished.</p>

<p>It will open default OS file manager and display
given <code>local_path</code> to the user so he can do something with the file.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/file/explore/v1?local_path=/tmp/movies/back_to_the_future.mp4'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "file_explore", "kwargs": {"local_path": "/tmp/movies/back_to_the_future.mp4"} }');
</code></pre>

<h4 class="api_method" id="shares_list">shares_list(only_active=False, include_mine=True, include_granted=True)</h4>

<p>Returns a list of registered "shares" - encrypted locations where you can upload/download files.</p>

<p>Use <code>only_active=True</code> to select only connected shares.</p>

<p>Parameters <code>include_mine</code> and <code>include_granted</code> can be used to filter shares created by you,
or by other users that shared a key with you before.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/share/list/v1?only_active=1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "shares_list", "kwargs": {"only_active": 1} }');
</code></pre>

<h4 class="api_method" id="share_create">share_create(owner_id=None, key_size=None, label="")</h4>

<p>Creates a new "share" - virtual location where you or other users can upload/download files.</p>

<p>This method generates a new RSA private key that will be used to encrypt and decrypt files belongs to that share.</p>

<p>By default you are the owner of the new share and uploaded files will be stored by your suppliers.
You can also use <code>owner_id</code> parameter if you wish to set another owner for that new share location.
In that case files will be stored not on your suppliers but on his/her suppliers, if another user authorized the share.</p>

<p>Optional input parameter <code>key_size</code> can be 1024, 2048, 4096. If <code>key_size</code> was not passed, default value will be
populated from the <code>personal/private-key-size</code> program setting.</p>

<p>Parameter <code>label</code> can be used to attach some meaningful information about that share location.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/share/create/v1' -d '{"label": "my summer holidays"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "share_create", "kwargs": {"label": "my summer holidays"} }');
</code></pre>

<h4 class="api_method" id="share_delete">share_delete(key_id)</h4>

<p>Stop the active share identified by the <code>key_id</code> and erase the private key.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X DELETE 'localhost:8180/share/delete/v1' -d '{"key_id": "share_7e9726e2dccf9ebe6077070e98e78082$alice@server-a.com"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "share_delete", "kwargs": {"key_id": "share_7e9726e2dccf9ebe6077070e98e78082$alice@server-a.com"} }');
</code></pre>

<h4 class="api_method" id="share_grant">share_grant(key_id, trusted_user_id, timeout=30)</h4>

<p>Provide access to given share identified by <code>key_id</code> to another trusted user.</p>

<p>This method will transfer private key to remote user <code>trusted_user_id</code> and you both will be
able to upload/download file to the shared location.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X PUT 'localhost:8180/share/grant/v1' -d '{"key_id": "share_7e9726e2dccf9ebe6077070e98e78082$alice@server-a.com", "trusted_user_id": "bob@machine-b.net"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "share_grant", "kwargs": {"key_id": "share_7e9726e2dccf9ebe6077070e98e78082$alice@server-a.com", "trusted_user_id": "bob@machine-b.net"} }');
</code></pre>

<h4 class="api_method" id="share_open">share_open(key_id)</h4>

<p>Activates given share and initiate required connections to remote suppliers to make possible to upload and download shared files.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X PUT 'localhost:8180/share/open/v1' -d '{"key_id": "share_7e9726e2dccf9ebe6077070e98e78082$alice@server-a.com"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "share_open", "kwargs": {"key_id": "share_7e9726e2dccf9ebe6077070e98e78082$alice@server-a.com"} }');
</code></pre>

<h4 class="api_method" id="share_close">share_close(key_id)</h4>

<p>Disconnects and deactivate given share location.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X PUT 'localhost:8180/share/close/v1' -d '{"key_id": "share_7e9726e2dccf9ebe6077070e98e78082$alice@server-a.com"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "share_close", "kwargs": {"key_id": "share_7e9726e2dccf9ebe6077070e98e78082$alice@server-a.com"} }');
</code></pre>

<h4 class="api_method" id="share_history">share_history()</h4>

<p>Method is not implemented yet.</p>

<h4 class="api_method" id="groups_list">groups_list(only_active=False, include_mine=True, include_granted=True)</h4>

<p>Returns a list of registered message groups.</p>

<p>Use <code>only_active=True</code> to select only connected and active groups.</p>

<p>Parameters <code>include_mine</code> and <code>include_granted</code> can be used to filter groups created by you,
or by other users that shared a key with you before.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/group/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "groups_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="group_create">group_create(creator_id=None, key_size=None, label="")</h4>

<p>Creates a new messaging group.</p>

<p>This method generates a new RSA private key that will be used to encrypt and decrypt messages streamed thru that group.</p>

<p>Optional input parameter <code>key_size</code> can be 1024, 2048, 4096. If <code>key_size</code> was not passed, default value will be
populated from the <code>personal/private-key-size</code> program setting.</p>

<p>Parameter <code>label</code> can be used to attach some meaningful information about that group.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/group/create/v1' -d '{"label": "chat with my friends"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "group_create", "kwargs": {"label": "chat with my friends"} }');
</code></pre>

<h4 class="api_method" id="group_info">group_info(group_key_id)</h4>

<p>Returns detailed info about the message group identified by <code>group_key_id</code>.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/group/info/v1?group_key_id=group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "group_info", "kwargs": {"group_key_id": "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com"} }');
</code></pre>

<h4 class="api_method" id="group_join">group_join(group_key_id)</h4>

<p>Activates given messaging group to be able to receive streamed messages or send a new message to the group.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/group/join/v1' -d '{"group_key_id": "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "group_join", "kwargs": {"group_key_id": "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com"} }');
</code></pre>

<h4 class="api_method" id="group_leave">group_leave(group_key_id, erase_key=False)</h4>

<p>Deactivates given messaging group. If <code>erase_key=True</code> will also erase the private key related to that group.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X DELETE 'localhost:8180/group/leave/v1' -d '{"group_key_id": "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "group_leave", "kwargs": {"group_key_id": "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com"} }');
</code></pre>

<h4 class="api_method" id="group_share">group_share(group_key_id, trusted_user_id, timeout=30)</h4>

<p>Provide access to given group identified by <code>group_key_id</code> to another trusted user.</p>

<p>This method will transfer private key to remote user <code>trusted_user_id</code> inviting him to the messaging group.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X PUT 'localhost:8180/group/share/v1' -d '{"group_key_id": "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com", "trusted_user_id": "bob@machine-b.net"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "group_share", "kwargs": {"key_id": "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com", "trusted_user_id": "bob@machine-b.net"} }');
</code></pre>

<h4 class="api_method" id="friends_list">friends_list()</h4>

<p>Returns list of registered correspondents.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/friend/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "friends_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="friend_add">friend_add(trusted_user_id, alias="")</h4>

<p>Add user to the list of correspondents.</p>

<p>You can attach an alias to that user as a label to be displayed in the UI.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/friend/add/v1' -d '{"trusted_user_id": "dave@device-d.gov", "alias": "SuperMario"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "friend_add", "kwargs": {"trusted_user_id": "dave@device-d.gov", "alias": "SuperMario"} }');
</code></pre>

<h4 class="api_method" id="friend_remove">friend_remove(user_id)</h4>

<p>Removes given user from the list of correspondents.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X DELETE 'localhost:8180/friend/add/v1' -d '{"user_id": "dave@device-d.gov"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "friend_add", "kwargs": {"user_id": "dave@device-d.gov"} }');
</code></pre>

<h4 class="api_method" id="user_ping">user_ping(user_id, timeout=15, retries=2)</h4>

<p>Sends <code>Identity</code> packet to remote peer and wait for an <code>Ack</code> packet to check connection status.</p>

<p>Method can be used to check and verify that remote node is on-line at the moment (if you are also on-line).</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/user/ping/v1?user_id=carol@computer-c.net'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "suppliers_ping", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="user_status">user_status(user_id)</h4>

<p>Returns short info about current on-line status of the given user.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/user/status/v1?user_id=carol@computer-c.net'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "user_status", "kwargs": {"user_id": "carol@computer-c.net"} }');
</code></pre>

<h4 class="api_method" id="user_status_check">user_status_check(user_id, timeout=5)</h4>

<p>Returns current online status of a user and only if node is known but disconnected performs "ping" operation.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/user/status/check/v1?user_id=carol@computer-c.net'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "user_status_check", "kwargs": {"user_id": "carol@computer-c.net"} }');
</code></pre>

<h4 class="api_method" id="user_search">user_search(nickname, attempts=1)</h4>

<p>Doing lookup of a single <code>nickname</code> registered in the DHT network.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/user/search/v1?nickname=carol'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "user_search", "kwargs": {"nickname": "carol"} }');
</code></pre>

<h4 class="api_method" id="user_observe">user_observe(nickname, attempts=3)</h4>

<p>Reads all records registered for given <code>nickname</code> in the DHT network.</p>

<p>It could be that multiple users chosen same nickname when creating an identity.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/user/observe/v1?nickname=carol'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "user_observe", "kwargs": {"nickname": "carol"} }');
</code></pre>

<h4 class="api_method" id="message_history">message_history(recipient_id=None, sender_id=None, message_type=None, offset=0, limit=100)</h4>

<p>Returns chat history stored during communications with given user or messaging group.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/message/history/v1?message_type=group_message&amp;recipient_id=group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "message_history", "kwargs": {"recipient_id" : "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com", "message_type": "group_message"} }');
</code></pre>

<h4 class="api_method" id="message_send">message_send(recipient_id, data, ping_timeout=30, message_ack_timeout=15)</h4>

<p>Sends a text message to remote peer, <code>recipient_id</code> is a string with a nickname, global_id or IDURL of the remote user.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/message/send/v1' -d '{"recipient_id": "carlos@computer-c.net", "data": {"message": "Hola Amigo!"}}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "message_send", "kwargs": {"recipient_id": "carlos@computer-c.net", "data": {"message": "Hola Amigos!"}} }');
</code></pre>

<h4 class="api_method" id="message_send_group">message_send_group(group_key_id, data)</h4>

<p>Sends a text message to a group of users.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/message/send/group/v1' -d '{"group_key_id": "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com", "data": {"message": "Hola Amigos!"}}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "message_send_group", "kwargs": {"group_key_id": "group_95d0fedc46308e2254477fcb96364af9$alice@server-a.com", "data": {"message": "Hola Amigos!"}} }');
</code></pre>

<h4 class="api_method" id="message_receive">message_receive(consumer_callback_id, direction="incoming", message_types="private_message,group_message", polling_timeout=60)</h4>

<p>This method can be used by clients to listen and process streaming messages.</p>

<p>If there are no pending messages received yet in the stream, this method will block and will be waiting for any message to come.</p>

<p>If some messages are already waiting in the stream to be consumed method will return them immediately.
As soon as client received and processed the response messages are marked as "consumed" and released from the stream.</p>

<p>Client should call that method again to listen for next messages in the stream. You can use <code>polling_timeout</code> parameter
to control blocking for receiving duration. This is very similar to a long polling technique.</p>

<p>Once client stopped calling that method and do not "consume" messages anymor given <code>consumer_callback_id</code> will be dropped
after 100 non-collected messages.</p>

<p>You can set parameter <code>direction=outgoing</code> to only populate messages you are sending to others - can be useful for UI clients.</p>

<p>Also you can use parameter <code>message_types</code> to select only specific types of messages: "private<em>message" or "group</em>message".</p>

<p>This method is only make sense for HTTP interface, because using a WebSocket client will receive streamed message directly.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/message/receive/my-client-group-messages/v1?message_types=group_message'
</code></pre>

<h4 class="api_method" id="suppliers_list">suppliers_list(customer_id=None, verbose=False)</h4>

<p>This method returns a list of your suppliers.
Those nodes stores your encrypted file or file uploaded by other users that still belongs to you.</p>

<p>Your BitDust node also sometimes need to connect to suppliers of other users to upload or download shared data.
Those external suppliers lists are cached and can be selected here with <code>customer_id</code> optional parameter.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/supplier/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "suppliers_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="supplier_change">supplier_change(position=None, supplier_id=None, new_supplier_id=None)</h4>

<p>The method will execute a fire/hire process for given supplier. You can specify which supplier to be replaced by position or ID.</p>

<p>If optional parameter <code>new_supplier_id</code> was not specified another random node will be found via DHT network and it will
replace the current supplier. Otherwise <code>new_supplier_id</code> must be an existing node in the network and
the process will try to connect and use that node as a new supplier.</p>

<p>As soon as new node is found and connected, rebuilding of all uploaded data will be automatically started and new supplier
will start getting reconstructed fragments of your data piece by piece.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/supplier/change/v1' -d '{"position": 1, "new_supplier_id": "carol@computer-c.net"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "supplier_change", "kwargs": {"position": 1, "new_supplier_id": "carol@computer-c.net"} }');
</code></pre>

<h4 class="api_method" id="suppliers_ping">suppliers_ping()</h4>

<p>Sends short requests to all suppliers to verify current connection status.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/supplier/ping/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "suppliers_ping", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="suppliers_dht_lookup">suppliers_dht_lookup(customer_id=None)</h4>

<p>Scans DHT network for key-value pairs related to given customer and returns a list its suppliers.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/supplier/list/dht/v1?customer_id=alice@server-a.com'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "suppliers_dht_lookup", "kwargs": {"customer_id": "alice@server-a.com"} }');
</code></pre>

<h4 class="api_method" id="customers_list">customers_list(verbose=False)</h4>

<p>Method returns list of your customers - nodes for whom you are storing data on that host.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/customer/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "customers_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="customer_reject">customer_reject(customer_id)</h4>

<p>Stop supporting given customer, remove all related files from local disc, close connections with that node.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X DELETE 'localhost:8180/customer/reject/v1' -d '{"customer_id": "dave@device-d.gov"}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "customer_reject", "kwargs": {"customer_id": "dave@device-d.gov"} }');
</code></pre>

<h4 class="api_method" id="customers_ping">customers_ping()</h4>

<p>Check current on-line status of all customers.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/customer/ping/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "customers_ping", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="space_donated">space_donated()</h4>

<p>Returns detailed info about quotas and usage of the storage space you donated to your customers.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/space/donated/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "space_donated", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="space_consumed">space_consumed()</h4>

<p>Returns info about current usage of the storage space provided by your suppliers.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/space/consumed/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "space_consumed", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="space_local">space_local()</h4>

<p>Returns info about current usage of your local disk drive.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/space/local/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "space_local", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="services_list">services_list(with_configs=False)</h4>

<p>Returns detailed info about all currently running network services.</p>

<p>Pass <code>with_configs=True</code> to also see current program settings values related to each service.</p>

<p>This is a very useful method when you need to investigate a problem in the software.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/service/list/v1?with_configs=1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "services_list", "kwargs": {"with_configs": 1} }');
</code></pre>

<h4 class="api_method" id="service_info">service_info(service_name)</h4>

<p>Returns detailed info about single service.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/service/info/service_private_groups/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "service_info", "kwargs": {"service_name": "service_private_groups"} }');
</code></pre>

<h4 class="api_method" id="service_start">service_start(service_name)</h4>

<p>Starts given service immediately.</p>

<p>This method also set <code>True</code> for correspondent option in the program settings to mark the service as enabled:</p>

<pre><code>.bitdust/config/services/[service name]/enabled
</code></pre>

<p>Other dependent services, if they were enabled before but stopped, also will be started.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/service/start/service_supplier/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "service_start", "kwargs": {"service_name": "service_supplier"} }');
</code></pre>

<h4 class="api_method" id="service_stop">service_stop(service_name)</h4>

<p>Stop given service immediately.</p>

<p>This method also set <code>False</code> for correspondent option in the program settings to mark the service as disabled:</p>

<pre><code>.bitdust/config/services/[service name]/enabled
</code></pre>

<p>Dependent services will be stopped as well but will not be disabled.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/service/stop/service_supplier/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "service_stop", "kwargs": {"service_name": "service_supplier"} }');
</code></pre>

<h4 class="api_method" id="service_restart">service_restart(service_name, wait_timeout=10)</h4>

<p>This method will stop given service and start it again, but only if it is already enabled.
It will not modify corresponding option for that service in the program settings.</p>

<p>All dependent services will be restarted as well.</p>

<p>Very useful method when you need to reload some parts of the application without full process restart.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/service/restart/service_customer/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "service_restart", "kwargs": {"service_name": "service_customer"} }');
</code></pre>

<h4 class="api_method" id="packets_list">packets_list()</h4>

<p>Returns list of incoming and outgoing signed packets running at the moment.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/packet/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "packets_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="packets_stats">packets_stats()</h4>

<p>Returns detailed info about overall network usage.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/packet/stats/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "packets_stats", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="transfers_list">transfers_list()</h4>

<p>Returns list of current data fragments transfers to/from suppliers.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/transfer/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "transfers_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="connections_list">connections_list(protocols=None)</h4>

<p>Returns list of opened/active network connections.</p>

<p>Argument <code>protocols</code> can be used to select which protocols to be present in the response:</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/connection/list/v1?protocols=tcp,udp,proxy'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "connections_list", "kwargs": {"protocols": ["tcp", "udp", "proxy"]} }');
</code></pre>

<h4 class="api_method" id="streams_list">streams_list(protocols=None)</h4>

<p>Returns list of running streams of data fragments with recent upload/download progress percentage.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/stream/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "streams_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="queues_list">queues_list()</h4>

<p>Returns list of registered streaming queues.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/queue/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "queues_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="queue_consumers_list">queue_consumers_list()</h4>

<p>Returns list of registered queue consumers.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/queue/consumer/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "queue_consumers_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="queue_producers_list">queue_producers_list()</h4>

<p>Returns list of registered queue producers.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/queue/producer/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "queue_producers_list", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="event_send">event_send(event_id, data=None)</h4>

<p>Method will generate and inject a new event inside the main process.</p>

<p>This method is provided for testing and development purposes.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/event/send/client-event-abc/v1' -d '{"data": {"some_key": "some_value"}}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "event_send", "kwargs": {"event_id": "client-event-produced", "data": {"some_key": "some_value"}} }');
</code></pre>

<h4 class="api_method" id="event_listen">event_listen(consumer_callback_id)</h4>

<p>This method can be used by clients to listen and process all events fired inside the main process.</p>

<p>If there are no pending events fired yet, this method will block and will be waiting for any new event.</p>

<p>If some messages are already waiting in the stream to be consumed method will return them immediately.
As soon as client received and processed the response events are marked as "consumed" and released from the buffer.</p>

<p>Client should call that method again to listen for next events. This is very similar to a long polling technique.</p>

<p>This method is only make sense for HTTP interface, because using a WebSocket client will receive application events directly.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/event/listen/my-client-event-hook/v1'
</code></pre>

<h4 class="api_method" id="network_stun">network_stun(udp_port=None, dht_port=None)</h4>

<p>Begins network STUN process to detect your network configuration and current external IP address of that host. </p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/network/stun/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "network_stun", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="network_reconnect">network_reconnect()</h4>

<p>Method can be used to refresh network status and restart all internal connections.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/network/reconnect/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "network_reconnect", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="network_connected">network_connected(wait_timeout=5)</h4>

<p>Method can be used by clients to ensure BitDust application is connected to other nodes in the network.</p>

<p>If all is good this method will block for <code>wait_timeout</code> seconds. In case of some network issues method will return result immediately.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/network/connected/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "network_connected", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="network_configuration">network_configuration()</h4>

<p>Returns details about network services.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/network/configuration/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "network_configuration", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="dht_node_find">dht_node_find(node_id_64=None, layer_id=0)</h4>

<p>Lookup "closest" (in terms of hashes and cryptography) DHT nodes to a given <code>node_id_64</code> value.</p>

<p>Method can be also used to pick a random DHT node from the network if you do not pass any value to <code>node_id_64</code>.</p>

<p>Parameter <code>layer_id</code> specifies which layer of the routing table to be used.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/dht/node/find/v1?node_id_64=4271c8f079695d77f80186ac9365e3df949ff74d'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "dht_node_find", "kwargs": {"node_id_64": "4271c8f079695d77f80186ac9365e3df949ff74d"} }');
</code></pre>

<h4 class="api_method" id="dht_user_random">dht_user_random(layer_id=0, count=1)</h4>

<p>Pick random live nodes from BitDust network.</p>

<p>Method is used during services discovery, for example when you need to hire a new supplier to store your data.</p>

<p>Parameter <code>layer_id</code> specifies which layer of the routing table to be used.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/dht/user/random/v1?count=2&amp;layer_id=2'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "dht_node_find", "kwargs": {"count": 2, "layer_id": 2} }');
</code></pre>

<h4 class="api_method" id="dht_value_get">dht_value_get(key, record_type="skip_validation", layer_id=0, use_cache_ttl=None)</h4>

<p>Fetch single key/value record from DHT network.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/dht/value/get/v1?key=abcd'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "dht_value_get", "kwargs": {"key": "abcd"} }');
</code></pre>

<h4 class="api_method" id="dht_value_set">dht_value_set(key, value, expire=None, record_type="skip_validation", layer_id=0)</h4>

<p>Writes given key/value record into DHT network. Input parameter <code>value</code> must be a JSON value.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X POST 'localhost:8180/dht/value/set/v1' -d '{"key": "abcd", "value": {"text": "A-B-C-D"}}'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "dht_value_set", "kwargs": {"key": "abcd", "value": {"text": "A-B-C-D"}} }');
</code></pre>

<h4 class="api_method" id="dht_local_db_dump">dht_local_db_dump()</h4>

<p>Method used for testing purposes, returns full list of all key/values stored locally on that DHT node.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/dht/db/dump/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "dht_local_db_dump", "kwargs": {} }');
</code></pre>

<h4 class="api_method" id="automats_list">automats_list()</h4>

<p>Returns a list of all currently running state machines.</p>

<p>This is a very useful method when you need to investigate a problem in the software.</p>

<h6 class="api_method_header" id="http">HTTP</h6>

<pre><code>curl -X GET 'localhost:8180/automat/list/v1'
</code></pre>

<h6 class="api_method_header" id="websocket">WebSocket</h6>

<pre><code>websocket.send('{"command": "api_call", "method": "automats_list", "kwargs": {} }');
</code></pre>

                            </div>


                        </div><!-- .docs-content -->
                    </div><!-- .row -->
                </div><!-- .card-body -->
            </div><!-- .ui-card -->

        </div><!-- .container -->
    </div><!-- #ui-api-docs -->

    <!-- Footer -->
    <footer class="ui-footer bg-gray">
        <div class="container pt-6 pb-6">
            <div class="row">
                <div class="col-sm-8 footer-about footer-col center-on-sm">
                    <img src="/assets/img/logo/bitdust-logo-white.svg"
                         alt="BitDust" />
                    <p class="mt-1">
                        We are currently with a small team primarily focusing on developing our product and
                        unfortunately don’t have the resources to support a community on different channels. For now you
                        can join the discussion on Telegram or if you have a business related question you can email us.
                    </p>
                </div>

                <div class="col-md-4 col-sm-6 footer-col center-on-sm">
                    <div>
                        <a class="btn ui-gradient-purple btn-circle shadow-md"
                           href="https://t.me/bitdust" target="_blank">
                            <span class="fa fa-telegram"></span>
                        </a>
                        <a class="btn ui-gradient-blue btn-circle shadow-md"
                           href="https://github.com/bitdust-io/" target="_blank">
                            <span class="fa fa-github"></span>
                        </a>
                        <a class="btn ui-gradient-green btn-circle shadow-md"
                           href="https://twitter.com/bitdust_io" target="_blank">
                            <span class="fa fa-twitter"></span>
                        </a>
                    </div>
                </div>
            </div><!-- .row -->
        </div><!-- .container -->

        <!-- Footer Copyright -->
        <div class="footer-copyright bg-dark-gray">
            <div class="container">
                <div class="row">
                    <!-- Copyright -->
                    <div class="col-sm-6 center-on-sm">
                        <p>
                            &copy; 2019 <a href="https://bitdust.io" target="_blank" title="BitDust">BitDust</a>
                        </p>
                    </div>
                    <!-- Social Icons -->
                    <div class="col-sm-6 text-right">
                        <ul class="footer-nav">
                            <li>
                                <a href="https://bitdust.io/wiki/">
                                    Wiki
                                </a>
                            </li>
                            <li>
                                <a href="https://github.com/bitdust-io/">
                                    Github
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>
            </div><!-- .container -->
        </div><!-- .footer-copyright -->

    </footer><!-- .ui-footer -->

</div><!-- .main -->


<!-- Scripts -->
<script src="/assets/js/libs/jquery/jquery-3.2.1.min.js"></script>
<script src="/assets/js/libs/slider-pro/jquery.sliderPro.min.js"></script>
<script src="/assets/js/libs/owl.carousel/owl.carousel.min.js"></script>

<script src="/assets/js/applify/ui-map.js"></script>
<script src="/assets/js/libs/form-validator/form-validator.min.js"></script>
<script src="/assets/js/libs/bootstrap.js"></script>
<script src="/assets/js/applify/build/applify.js"></script>

<script>
    $('a[href*=\\#]').on('click', function (event) {
        if ($(this.hash).offset() && $(this.hash).offset().top) {
            event.preventDefault();
            $('html,body').animate({scrollTop: $(this.hash).offset().top - 100}, 500);
            window.location.hash = this.hash;
        }
    });
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-25753370-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());

    gtag('config', 'UA-109832032-1');
</script>

</body>
</html>
